{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Eclipse Emfatic","text":"<p>Emfatic is a textual syntax for EMF Ecore (meta-)models. This page details the syntax of Emfatic and the mapping between Emfatic declarations and the corresponding Ecore constructs.</p> <p></p>"},{"location":"#packages","title":"Packages","text":"<p>Emfatic programs are shown in boxes as in the example below:</p> <pre><code>package test;\nclass Foo { }</code></pre> <p>When compiled, the program above will produce a model with an <code>EPackage</code> named \"test\" containing a single <code>EClass</code> named \"Foo\".</p> <p>As is probably clear from the first Emfatic program above, the keyword package introduces an Ecore <code>EPackage</code> and the identifier following it maps to the <code>name</code> attribute of the generated <code>EPackage</code>.</p>"},{"location":"#main-package","title":"Main Package","text":"<p>The only thing required in an Emfatic source file is a package declaration.\u00a0 This required element is called the main package declaration and the <code>EPackage</code> it defines will contain (directly or indirectly) all of the other elements of the generated Ecore model.\u00a0 Thus the simplest possible Emfatic program would look something like this:</p> <pre><code>package p;</code></pre> <p>Specifying values for the <code>EPackage</code> attributes <code>nsURI</code> and <code>nsPrefix</code> is done like this:</p> <pre><code>@namespace(uri=\"http://www.eclipse.org/emf/2002/Ecore\", prefix=\"ecore\")\npackage ecore;</code></pre> <p>Note that Emfatic is case-sensitive in most contexts (reflecting the underlying case-sensitivity of Ecore), however the identifiers namespace, uri and prefix in the text above could be written in any case.\u00a0 Also note that the order of declaration for uri and prefix is not important.\u00a0The syntax of the @namespace declaration is actually a special case of the more general syntax for declaring EAnnotations, which will be described in full detail below.</p>"},{"location":"#sub-packages","title":"Sub-Packages","text":"<p>Warning</p> <p>While Ecore and Emfatic support nested/sub-packages, their use is discouraged as many tools that build on top of EMF don't work well with them.</p> <p>Ecore allows packages to be nested inside packages.\u00a0 In Emfatic, the syntax for nested packages differs from that of the main package.\u00a0 Nested package declarations are followed by a curly-brace bracketed region which encloses the nested package contents.\u00a0 The example below demonstrates package nesting.</p> <pre><code>package main;\n\npackage sub1 {\n}\n\npackage sub2 {\n  package sub2_1 { }\n  package sub2_2 { }\n}</code></pre> <p>In the Ecore model generated from the above program, the top-level package named \"main\" will contain two packages, \"sub1\" and \"sub2\", and package sub2 will contain the packages \"sub2_1\" and \"sub2_2\".</p>"},{"location":"#main-package-imports","title":"Main Package Imports","text":"<p>Import statements allow for types defined in external Ecore models to be referenced.\u00a0 All import statements must immediately follow the main package declaration.\u00a0 The example below demonstrates the basic syntax of import statements.\u00a0 The double-quoted string literal following the import keyword must contain the URI of an Ecore model.</p> <pre><code>package main;\nimport \"platform:/resource/proj1/foo.ecore\";\nimport \"http://www.eclipse.org/emf/2002/Ecore\";\n\npackage sub { }</code></pre> <p>Note that Ecore.ecore is automatically imported, so the second import in the program above is not really necessary.</p>"},{"location":"#classifiers","title":"Classifiers","text":""},{"location":"#classes","title":"Classes","text":"<p>The Emfatic syntax for class declarations is very similar to Java, however a few quirks are required to allow for all of the possibilities of Ecore.\u00a0 The example below containing four simple class declarations demonstrates the use of the keywords <code>class</code>, <code>interface</code> and <code>abstract</code> and also introduces Emfatic comments (Emfatic allows both styles of Java comments).\u00a0 The comments detail the mapping from Emfatic to the <code>EClass</code> attributes <code>interface</code> and <code>abstract</code>.</p> <pre><code>package main;\nclass C1 { } // isInterface=false, isAbstract=false\nabstract class C2 { } // isInterface=false, isAbstract=true\ninterface I1 { } // isInterface=true,\u00a0 isAbstract=false\nabstract interface I2 { } // isInterface=true,\u00a0 isAbstract=true</code></pre> <p>Inheritance is specified with the keyword <code>extends</code>. Unlike Java, there is no <code>implements</code> keyword to distinguish inheritance from interface implementation.\u00a0 The example below defines an inheritance hierarchy.</p> <pre><code>package main;\nclass A { }\nclass B { }\nclass C extends A, B { }\nclass D extends C { }</code></pre> <p>If necessary, the value of the <code>EClassifier</code> attribute <code>instanceClassName</code> can be specified. The class <code>EStringToStringMapEntry</code> from Ecore.ecore provides an example of this:</p> <pre><code>class EStringToStringMapEntry : java.util.Map$Entry {\n  // ... contents omitted ...\n}</code></pre> <p>Note that if the class both extends other classes and specifies a value for <code>instanceClassName</code>, the extends clause must precede the <code>instanceClassName</code> clause.</p>"},{"location":"#data-types","title":"Data Types","text":"<p>Declaring an <code>EDataType</code> is fairly simple.\u00a0 Here are some familiar examples from Ecore.ecore:</p> <pre><code>datatype EInt : int;\ndatatype EIntegerObject : java.lang.Integer;\ntransient datatype EJavaObject : java.lang.Object;\n\ndatatype EFeatureMapEntry : org.eclipse.emf.ecore.util.FeatureMap$Entry;\ndatatype EByteArray : \"byte[]\";\u00a0 // Note: [ and ] are not legal identifier characters and must be in quotes</code></pre> <p>First note that as with classes, the value of the <code>EClassifier</code> attribute <code>instanceClassName</code> follows the colon after the name of the datatype.\u00a0 However specifying <code>instanceClassName</code> is required for datatypes (while it is optional for classes).</p> <p>The keyword <code>transient</code> in the third datatype declaration above indicates that the value of the <code>EDataType</code> <code>serializable</code> attribute should be set to false. This is a good time to point out that the modifier keywords introduced so far (<code>abstract</code> and <code>interface</code>) are applied to reverse the default Ecore attribute values (by default <code>EClass</code> attributes <code>abstract</code> and <code>interface</code> are both false).\u00a0 In the case of the <code>EDataType</code> attribute <code>serializable</code>, the default value is true so Emfatic uses a keyword, <code>transient</code>, that means the opposite of serializable.</p> <p>The last two datatypes illustrate a subtle syntactic point.\u00a0 The value specified for the <code>instanceClassName</code> attribute must either be a valid qualified identifier (a dot or dollar-sign separated list of identifiers such as <code>java.lang.Object</code> in the third datatype above) or it must be enclosed in double quotes.\u00a0 The datatype EFeatureMapEntry contains the character '<code>$</code>' which, following Java syntactic rules, is a legal qualified identifier separator.\u00a0 The datatype EByteArray contains the characters '<code>[</code>' and '<code>]</code>' which are not legal in a qualified identifier.</p> <p>The overall point to make about qualified identifier versus double-quoted syntax for <code>instanceClassName</code> is that the typical datatype declaration can use the former and thus should be easier to read and edit, while the latter is available when needed and allows for arbitrary string text to be placed in the generated Ecore model.\u00a0 There are some other contexts where the Emfatic programmer has the option to use either a qualified identifier or double-quoted string (see the section on Annotations below for another example of this).</p>"},{"location":"#enumerated-types","title":"Enumerated Types","text":"<p>The example below demonstrates the Emfatic syntax that maps to <code>EEnum</code> and <code>EEnumLiteral</code>.\u00a0 Note that the simple assignment expressions specify the <code>value</code> attribute of each generated <code>EEnumLiteral</code>.</p> <pre><code>enum E {\n  A=1;\n  B=2;\n  C=3;\n}</code></pre> <p>In fact, specifying enumeration literal values is optional and Emfatic generates reasonable values when they are left unspecified.\u00a0 The code and comments below describe the rules for this.</p> <pre><code>enum E {\n  A;  // = 0 (if not specified, first literal has value 0)\n  B = 3;\n  C; // = 4 (in general, unspecified values are 1 greater than previous value)\n  D; // = 5\n}</code></pre>"},{"location":"#map-entries","title":"Map Entries","text":"<p>MapEntry classes (such as <code>EStringToStringMapEntry</code> in Ecore.ecore) can be specified in either of two ways.\u00a0 The \"longhand\" way is to declare a class with features named <code>key</code> and <code>value</code> and with <code>[instanceClass=java.util.Map$Entry]</code> as suggested at the end of section 2.1 above. But there is a convienent shorthand notation which achieves the same result:</p> <pre><code>mapentry EStringToStringMapEntry : String -&gt; String;</code></pre> <p>The expression following the colon gives the type of the MapEntry <code>key</code> structural feature followed by the <code>-&gt;</code> operator, followed by the type of the <code>value</code> structural feature.\u00a0 Type expressions can be more complex than shown in the example above and are detailed fully in the next section.</p>"},{"location":"#type-expressions","title":"Type Expressions","text":"<p>The most basic Ecore elements that haven't yet been explored in Emfatic are the structural and behavioral class features represented by the Ecore classes <code>EAttribute</code>, <code>EReference</code>, <code>EOperation</code> and <code>EParameter</code>.\u00a0 These four Ecore classes are all derived from <code>ETypedElement</code> which means that instances of them have some type (which is an <code>EClassifier</code>) and inherit the other characteristics of <code>ETypedElement</code>, like multiplicity.\u00a0 Before we can describe each specific kind of class feature, we need to show how types are represented syntactically, because that applies (more or less) to all of them.</p> <p>Type expressions have two parts.\u00a0 First is a simple identifier or a qualified identifier (a dot-separated list of simple identifiers like \"a.b.c\") that identifies some <code>EClassifier</code>.\u00a0 The <code>EClassifier</code> identified may be defined in the same Emfatic source file as the type expression, or it may be in one of the imported Ecore models (specified in import statements).</p> <p>Let's skip ahead a little by looking at some attribute declarations so that we can talk about their type expressions:</p> <pre><code>package test;\n\ndatatype D1 : int;\n\npackage P {\n  datatype D2 : int;\n}\n\nclass C {\n  attr D1 d1;\n  attr P.D2 d2;\n  attr ecore.EString s1;\n  attr String s2;\n}</code></pre> <p>The class named \"C\" above declares four attributes with the names \"d1\", \"d2\", \"s1\" and \"s2\".\u00a0 Note that Emfatic follows Java syntactic style in placing type expression before the name.\u00a0 However unlike Java field declarations, Emfatic uses a keyword - <code>attr</code> - to introduce an attribute. (The keyword <code>attr</code> and similar keywords to introduce references and operations will explained in more detail in the following sub-sections).</p> <p>The type expression for d1 is \"D1\" which identifies the datatype D1.\u00a0 Because C and D1 are in the same package (test), this simple expression is fine.</p> <p>The type expression for d2 is \"P.D2\".\u00a0 In this case a qualified identifier expression is necessary to identify datatype D2 inside package P.</p> <p>The type expression for s1 is \"ecore.EString\".\u00a0 This identifies the datatype EString in package ecore (recall that model Ecore.ecore is implicitly imported in all Emfatic programs).</p> <p>The type expression for s2 is \"String\".\u00a0 The identifier String is actually a special shorthand for ecore.EString, so s1 and s2 have the same type.</p>"},{"location":"#basic-types","title":"Basic Types","text":"<p>A number of the types defined in Ecore.ecore have shorthand notation in Emfatic.\u00a0 The table below lists the Emfatic shorthand and the corresponding Ecore.ecore type name for each of these basic types as well as the corresponding Java type or class.</p> Emfatic Keyword Ecore EClassifier name Java type name boolean EBoolean boolean Boolean EBooleanObject java.lang.Boolean byte EByte byte Byte EByteObject java.lang.Byte char EChar char Character ECharacterObject java.lang.Character double EDouble double Double EDoubleObject java.lang.Double float EFloat float Float EFloatObject java.lang.Float int EInt int Integer EIntegerObject java.lang.Integer long ELong long Long ELongObject java.lang.Long short EShort short Short EShortObject java.lang.Short Date EDate java.util.Date String EString java.lang.String Object EJavaObject java.lang.Object Class EJavaClass java.lang.Class EObject EObject org.eclipse.emf.ecore.EObject EClass EClass org.eclipse.emf.ecore.EClass <p>Remember that you can always reference these types, and the rest of the types in Ecore.ecore, by using their fully qualified name which begins with the package prefix \"ecore\".\u00a0 For example <code>ecore.EOperation</code> and <code>ecore.EBigInteger</code> are also legal references to types in Ecore.ecore.</p>"},{"location":"#multiplicity-expressions","title":"Multiplicity Expressions","text":"<p>The second part of a type expression is the multiplicity expression.\u00a0 This maps to the <code>lowerBound</code> and <code>upperBound</code> attributes of <code>ETypedElement</code>.\u00a0 Multiplicity expressions are optional, but when omitted the generated <code>ETypedElement</code> gets the defaults (<code>lowerBound</code> = 0 and <code>upperBound</code> = 1).\u00a0 The example below shows some attribute declarations with multiplicity expressions:</p> <pre><code>class C {\n  attr String[1] s1;\n  attr String[0..3] s2;\n  attr String[*] s3;\n  attr String[+] s4;\n}</code></pre> <p>The mapping between various multiplicity expressions and the <code>lowerBound</code> and <code>upperBound</code> attributes of the generated <code>ETypedElement</code> is detailed more fully in the following table.</p> Emfatic multiplicity expression ETypedElement lowerBound ETypedElement upperBound none 0 1 [?] 0 1 [] 0 unbounded (-1) [*] 0 unbounded (-1) [+] 1 unbounded (-1) [1] 1 1 [n] n n [0..4] 0 4 [m..n] m n [5..*] 5 unbounded (-1) [1..?] 1 unspecified (-2)"},{"location":"#escaping-keywords","title":"Escaping Keywords","text":"<p>Sometimes it's necessary or desirable to use a keyword as the name for some model element.\u00a0 This can be acheived by prefixing the name identifier with the '<code>~</code>' symbol.\u00a0 This ability was added primarily to make it possible to represent Ecore.ecore in Emfatic, so we'll show another example from Ecore.ecore here to illustrate:</p> <pre><code>class EClass extends EClassifier\n{\n  // ...\n  ~abstract : EBoolean;\n  ~interface : EBoolean;\n  // ...\n}</code></pre> <p>Recall that the <code>abstract</code> and <code>interface</code> keywords are used in class declarations.\u00a0 The code above shows how they can be used as attribute names.\u00a0 Emfatic removes the '<code>~</code>' symbol so names in the generated Ecore model do not contain it.</p>"},{"location":"#structural-and-behavioral-features","title":"Structural and Behavioral Features","text":"<p>Now we are ready to show how the Ecore class features <code>EAttribute</code>, <code>EReference</code>, <code>EOperation</code> and <code>EParameter</code> are represented in Emfatic.\u00a0 The example below is the class <code>EPackage</code> from Ecore.ecore and it was chosen to give a feel for the feature syntax because it contains a sample of each kind of class feature.\u00a0</p> <pre><code>class EPackage extends ENamedElement {\n  op EClassifier getEClassifier(EString name);\n  attr EString nsURI;\n  attr EString nsPrefix;\n  transient !resolve ref EFactory[1]#ePackage eFactoryInstance;\n  val EClassifier[*]#ePackage eClassifiers;\n  val EPackage[*]#eSuperPackage eSubpackages;\n  readonly transient ref EPackage#eSubpackages eSuperPackage;\n}</code></pre> <p>For now we just want to point out that the syntax for class features is based on the syntax of Java with one key difference.\u00a0 In Java some elements are introduced with special keywords like <code>class</code> and <code>interface</code>, but type members like fields and methods have no such keywords to introduce them.\u00a0 This works for Java because fields and methods can be distinguished by looking at other syntactic featues (methods have parenthesis and fields do not).\u00a0 However the distinction between what EMF calls attributes and references doesn't really exist in Java, so there is no distinguishing syntax.\u00a0 Because of this and because class features are such an essential element of EMF, a decision was made to use keywords to introduce and differentiate attributes, references and operations.\u00a0 Thus in Emfatic the basic syntax for a class feature looks like this: </p> <pre><code>modifiers \u00a0 featureKind \u00a0 typeExpression \u00a0 name \u00a0 ';'\n</code></pre> <p>Where <code>featureKind</code> is one of the four keywords in the following table.</p> Emfatic keyword introduces attr EAttribute op EOperation ref normal EReference (EReference.containment = false) val \"by value\" EReference (EReference.containment = true)"},{"location":"#modifiers","title":"Modifiers","text":"<p>Look again at the Emfatic code above for <code>EPackage</code> and note in the last class feature declaration the keyword <code>ref</code> is preceded by the words <code>readonly</code> and <code>transient</code>.\u00a0 These are modifiers similar in spirit to Java's modifiers such as <code>public</code>, <code>private</code> and <code>abstract</code>.\u00a0 However these modifiers map to boolean attributes on the Ecore classes involved in defining structural and behavioral features.\u00a0 These modifiers must appear directly before the feature's type expression.\u00a0 The table below describes each modifier.</p> Modifier Means Applies to readonly EStructuralFeature.changeable = false attribute, reference volatile EStructuralFeature.volatile = true attribute, reference transient EStructuralFeature.transient = true attribute, reference unsettable EStructuralFeature.unsettable = true attribute, reference derived EStructuralFeature.derived = true attribute, reference unique ETypedElement.unique = true attribute, reference, operation, parameter ordered ETypedElement.ordered = true attribute, reference, operation, parameter resolve EReference.resolveProxies = true reference id EAttribute.iD = true attribute <p>Note that the meaning of a modifier may be negated by prefixing the <code>!</code> operator.\u00a0 The example below demonstrates this with an non-ordered attribute:</p> <pre><code>class X {\n  !ordered attr String[*] s;\n}</code></pre> <p>Normally the only modifiers that you should see negated with <code>!</code> are <code>unique</code>, <code>ordered</code> and <code>resolve</code>.\u00a0 This is because these three are true by default, so reversing the Ecore default means using the <code>!</code> operator.\u00a0 Note also that <code>EStructuralFeature.changeable</code> is true by default, but the modifier keyword <code>readonly</code> means the opposite (<code>EStructuralFeature.changeable</code> = false).</p>"},{"location":"#attributes","title":"Attributes","text":"<p>We've now seen attribute naming and type expressions.\u00a0 Attributes may also be assigned default value expressions.\u00a0 Below is an example showing the various forms of attribute syntax.</p> <pre><code>class C {\n  attr String s;\n  attr int i = 1;\n  attr ecore.EBoolean b = true;\n}</code></pre> <p>Again note that the declaration of attributes is basically identical to declaring fields in Java except for the presence of the <code>attr</code> keyword.</p>"},{"location":"#references","title":"References","text":"<p>The type expression syntax for references is slightly complicated by the fact that we need some way to identify the opposite of a reference.\u00a0 Let's return again to the code for <code>EPackage</code>, but we'll just look at the last two feature declarations:</p> <pre><code>class EPackage extends ENamedElement {\n  // ...\n  val EPackage[*]#eSuperPackage eSubpackages;\n  readonly transient ref EPackage#eSubpackages eSuperPackage;\n}</code></pre> <p>Notice that the type expressions are followed by a <code>#</code> symbol and an identifier.\u00a0 This identifier names the <code>EReference</code> which is the <code>opposite</code> of the reference being declared.\u00a0 If a reference doesn't need to specify its opposite then that part (including the <code>#</code> symbol) is omitted.</p>"},{"location":"#operations","title":"Operations","text":"<p>The declaration syntax for operations is Java-like as described above, including use of the keyword <code>void</code> to identify operations which don't return a value.\u00a0 Also a Java-like <code>throws</code> clause allows for the declaration of exception types:</p> <pre><code>class X {\n  op String getFullName();\n  op void returnsNothing();\n  op int add(int a, int b);\n  op EObject doSomething(int a, ecore.EBoolean b) throws ExceptionA, ExceptionB;\n}</code></pre>"},{"location":"#annotations","title":"Annotations","text":"<p>Annotations can be attached to every kind of EMF element, however only the <code>source</code> and <code>details</code> features of the resulting <code>EAnnotation</code> can be specified in Emfatic.\u00a0 The Emfatic syntax for representing EMF annotations was inspired by the syntax being introduced for Java annotations in Java 1.5 (\"Tiger\").\u00a0 The <code>@</code> symbol is followed by the value of the <code>EAnnotation</code> <code>source</code> attribute.\u00a0 Key/value pairs for the annotation <code>details</code> may appear in parenthesis following the <code>source</code> value.\u00a0 Multiple annotations can be attached to each element.\u00a0 Usually the annotation appears just before its containing element (parameter and enum literal annotations may appear just after the declaration).\u00a0 The example below gives some examples of annotations.</p> <pre><code>@\"http://source/uri\"(\"key1\"=\"value1\", \"key2\"=\"value2\")\n@sourceLabel(key.a=\"value1\", key.b=\"value2\")\n@simpleAttr\npackage test;\n\n@\"http://class/annotation\"(k=\"v\")\nclass C {\n  @\"http://attribute/annotation\"(k=\"v\")\n  attr int a;\n\n  op int Op(\n\n    @before(k=v) int a,\n    int b @after(k=v)\n   );\n}\n\nenum E { \n  @\"http://before\"(k=v) \n  A=1; \n  B=2 @\"http://after\"(k=v); \n}</code></pre> <p>One subtle point to note is that double quotes are only required around the string value if it is not a valid simple or qualified identifier.\u00a0 So an identifier like <code>key</code> or <code>key.a.b.c</code> need not be quoted, but most complex strings (such as urls) will need to be.</p>"},{"location":"#annotation-labels","title":"Annotation Labels","text":"<p>Emfatic allows for short labels to be defined that map to longer URI values for the <code>source</code> attribute of an <code>EAnnotation</code>.\u00a0 The purpose of this feature is to simplify the Emfatic code, making it easier to read and edit.\u00a0 Several annotation labels are available by default, as shown in the following table:</p> Emfatic annotation label maps to EAnnotation.source value Ecore http://www.eclipse.org/emf/2002/Ecore GenModel http://www.eclipse.org/emf/2002/GenModel ExtendedMetaData http:///org/eclipse/emf/ecore/util/ExtendedMetaData EmfaticAnnotationMap http://www.eclipse.org/emf/2004/EmfaticAnnotationMap <p>The code below shows some examples:</p> <pre><code>@EmfaticAnnotationMap(myLabel=\"http://foo/bar\")\n@genmodel(documentation=\"model documentation\")\npackage test;\n\n@ecore(constraints=\"constraintA constraintB\")\n@myLabel(key=\"value\")\nclass C {\n}</code></pre> <p>There are several details to elaborate on in the example above.\u00a0 First note that labels are not case sensitive (so <code>Ecore</code> and <code>ecore</code> and <code>ECORE</code> all work the same way).</p> <p>Second, note that declaring an annotation using the label <code>EmfaticAnnotationMap</code> has the side effect of creating a new label which can be used later in the program.\u00a0 So the second annotation on class \"C\" will get the <code>source</code> value of <code>\"http://foo/bar\"</code>.</p> <p>Finally, note that the code above shows how to introduce model documentation and constraints in a way that will later flow into generated Java code when working with an EMF genmodel.</p>"},{"location":"#about","title":"About","text":"<p>This article was originally written by Chris Daly (cjdaly@us.ibm.com) (Copyright IBM Corp. 2004) and was hosted under IBM alphaWorks.</p>"},{"location":"download/","title":"Download","text":"<p>You can use the following update sites through the <code>Help-&gt;Install new software</code> menu in Eclipse to install Emfatic.</p> Site Location Stable <code>http://download.eclipse.org/emfatic/update</code> Interim <code>http://download.eclipse.org/emfatic/interim</code>"},{"location":"download/#maven","title":"Maven","text":"<p>JARs of stable versions of Emfatic are available on Maven Central. Emfatic interm JARs are available from Sonatype. To use the Emfatic from your <code>pom.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n&lt;groupId&gt;org.eclipse.emfatic&lt;/groupId&gt;\n&lt;artifactId&gt;standalone-example&lt;/artifactId&gt;\n&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n\n&lt;repositories&gt;\n&lt;repository&gt;\n&lt;id&gt;Sonatype&lt;/id&gt;\n&lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n\n&lt;properties&gt;\n&lt;epsilon.scope&gt;compile&lt;/epsilon.scope&gt;\n&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.eclipse.emfatic&lt;/groupId&gt;\n&lt;artifactId&gt;org.eclipse.emfatic.core&lt;/artifactId&gt;\n&lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>"}]}